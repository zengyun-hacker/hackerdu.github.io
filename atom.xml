<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Du&#39;s Time</title>
  
  <subtitle>Coding, thinking and maybe something else</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://codingtime.me/"/>
  <updated>2018-09-15T12:01:30.632Z</updated>
  <id>http://codingtime.me/</id>
  
  <author>
    <name>Du</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何打出同时支持真机和模拟器的 Framework</title>
    <link href="http://codingtime.me/2018/09/15/build-fat-framework/"/>
    <id>http://codingtime.me/2018/09/15/build-fat-framework/</id>
    <published>2018-09-15T11:54:36.000Z</published>
    <updated>2018-09-15T12:01:30.632Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>创建一个 Framework 的 target，将需要的所有文件拖入 target 中</p></li><li><p>先将目标设备选为真机，build，然后在 product 里找到打好的 framework</p></li><li><p>再将目标设备选为模拟器，build，然后在 product 里找到打好的 framework</p></li><li><p>执行 lipo 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -create '真机版 frameworkd 的露囧' '模拟器版 framework 的路径' -output '新的framework的名称'</span><br></pre></td></tr></table></figure><p>生成的新 framework 就同时支持真机和模拟器架构了~</p></li></ol><p>相关资料：</p><p><a href="https://stackoverflow.com/questions/29634466/how-to-export-fat-cocoa-touch-framework-for-simulator-and-device" target="_blank" rel="noopener">How to export “fat” Cocoa Touch Framework (for Simulator and Device)?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建一个 Framework 的 target，将需要的所有文件拖入 target 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;先将目标设备选为真机，build，然后在 product 里找到打好的 framework&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;再将目标
      
    
    </summary>
    
      <category term="iOS周边知识" scheme="http://codingtime.me/categories/iOS%E5%91%A8%E8%BE%B9%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="iOS" scheme="http://codingtime.me/tags/iOS/"/>
    
      <category term="编译" scheme="http://codingtime.me/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>使用 iOS 10.3 新 API 给 app 更换 icon</title>
    <link href="http://codingtime.me/2017/08/16/%E4%BD%BF%E7%94%A8iOS%2010.3%20%E6%96%B0%20API%20%E7%BB%99%20app%20%E6%9B%B4%E6%8D%A2%20icon/"/>
    <id>http://codingtime.me/2017/08/16/使用iOS 10.3 新 API 给 app 更换 icon/</id>
    <published>2017-08-16T15:26:58.000Z</published>
    <updated>2018-07-15T16:13:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 10.3 出来好长一段时间了，其中有一个换 icon 的 API <code>setAlternateIconName</code> 感觉挺好玩的一直想试一把。实验结果如下。</p><ol><li>首先准备好几个icon，根据苹果爸爸的要求，icon 2x 图尺寸为 120x120，3x 图尺寸为 180x180。</li><li><p>把这几个 icon 拖到工程中，这里有几个注意点：</p><ol><li>图片直接当做资源拖到工程中，不要放到Assets里</li><li>如果之前app的icon是用Assets管理的，把Assets里的AppIcon删掉，并把 Target -&gt; General -&gt; App Icons and Launch Images 里的 App Icon Source 改成 Don’t use assets catalogs<br><img src="media/15028867535241.jpg" alt=""></li></ol></li></ol><ol start="3"><li><p>在 <code>Info.plis</code> 中加入以下字段，<code>CFBundleAlternateIcons</code>字段部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;supportsAlternateIcons&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;CFBundleIcons&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;CFBundlePrimaryIcon&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;CFBundleIconFiles&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;主icon文件名，不带后缀&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;key&gt;UIPrerenderedIcon&lt;/key&gt;</span><br><span class="line">&lt;false/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;key&gt;CFBundleAlternateIcons&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;此处填入自定义icon的文件名，不带后缀&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;CFBundleIconFiles&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;此处填入自定义icon的文件名，不带后缀&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;key&gt;UIPrerenderedIcon&lt;/key&gt;</span><br><span class="line">&lt;false/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;key&gt;此处填入另一个自定义icon的文件名&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;CFBundleIconFiles&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;此处填入另一个自定义icon的文件名&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;key&gt;UIPrerenderedIcon&lt;/key&gt;</span><br><span class="line">&lt;false/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure></li><li><p>在代码中调用 <code>setAlternateIconName</code> 更换icon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Swift版本</span><br><span class="line">UIApplication.shared.setAlternateIconName(iconName, completionHandler: &#123; (error) in</span><br><span class="line">              if let error = error &#123;</span><br><span class="line">                  print(error.localizedDescription)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objective-C 版本</span></span><br><span class="line"> [[<span class="built_in">UIApplication</span> sharedApplication] setAlternateIconName:<span class="string">@"icon_new"</span> completionHandler:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"error = %@"</span>, error.localizedDescription);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure></li></ol><p>  调用成功之后，系统会自动弹出 icon 更换的提示框<br>  <img src="media/15028870063460.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS 10.3 出来好长一段时间了，其中有一个换 icon 的 API &lt;code&gt;setAlternateIconName&lt;/code&gt; 感觉挺好玩的一直想试一把。实验结果如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先准备好几个icon，根据苹果爸爸的要求，icon 2x 图尺
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://codingtime.me/tags/iOS/"/>
    
      <category term="开发" scheme="http://codingtime.me/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>如何获取UIWebView请求时的HTTP状态码</title>
    <link href="http://codingtime.me/2017/03/08/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96UIWebView%E8%AF%B7%E6%B1%82%E6%97%B6%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://codingtime.me/2017/03/08/如何获取UIWebView请求时的HTTP状态码/</id>
    <published>2017-03-08T09:53:00.000Z</published>
    <updated>2018-07-15T19:11:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们需要向前端一样为请求错误的UIWebView界面添加更好看的本地错误提示，这就需要获取到UIWebView请求网页的HTTP状态码，基本思路是在webView请求结束后获取到缓存中的response，再根据response的statusCode进行判断，因此截获操作应该在<code>UIWebViewDelegate</code>中的<code>webViewDidFinishLoad</code>方法中进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView&#123;</span><br><span class="line">...</span><br><span class="line">//获取status code</span><br><span class="line">NSHTTPURLResponse *response = (NSHTTPURLResponse *)[[NSURLCache sharedURLCache] cachedResponseForRequest:webView.request].response;</span><br><span class="line">NSInteger statusCode = response.statusCode;</span><br><span class="line">if (statusCode == 404) &#123;//或者换成你想要的其他状态码</span><br><span class="line">    //捕捉到404</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时我们需要向前端一样为请求错误的UIWebView界面添加更好看的本地错误提示，这就需要获取到UIWebView请求网页的HTTP状态码，基本思路是在webView请求结束后获取到缓存中的response，再根据response的statusCode进行判断，因此截获操作
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://codingtime.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Taptic Engine初探</title>
    <link href="http://codingtime.me/2017/01/29/Taptic%20Engine%E5%88%9D%E6%8E%A2/"/>
    <id>http://codingtime.me/2017/01/29/Taptic Engine初探/</id>
    <published>2017-01-29T09:53:00.000Z</published>
    <updated>2018-07-15T19:03:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>感谢组织过年借我只iPhone 7P，赶紧呈上一篇Taptic Engine报答组织</p></blockquote><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>Taptic Engine 是苹果的触觉反馈技术，其中<code>Taptic</code>演变自<code>Haptic</code>，即触觉。<br>Taptic Engine目前已经应用在苹果全线设备中。它让Apple Watch震动时有手腕被人拍了一下的感觉。让MacBook触摸板有以假乱真的触感（Force Touch）。而在iPhone上，除了实现了3D Touch让屏幕多了一维交互外，还实现了虚拟Home键的反馈效果，甚至还提供了一套Taptic API供开发者实现自己的震动反馈。</p><h2 id="何时使用触摸反馈"><a href="#何时使用触摸反馈" class="headerlink" title="何时使用触摸反馈"></a>何时使用触摸反馈</h2><p>为了保证所有app体验的一致性，苹果总结了适合触摸反馈的场景，收录于<a href="https://developer.apple.com/ios/human-interface-guidelines/interaction/feedback/#haptics" target="_blank" rel="noopener">iOS Human Interface Guidelines</a>中，规范中将触摸反馈的使用场景分为三类：Notification、Impact和Seleciton。</p><p>Notification用来表示成功、失败或者警告的反馈，Impact用于加强用户对物理碰撞体验，Selection用于表示用户选择区域的变化。<br>苹果在其官方文档里反复强调了<code>在用户确定需要反馈的时候再使用，不要因为触摸反馈帅就乱用</code>，再加上<a href="https://forums.developer.apple.com/thread/62222" target="_blank" rel="noopener">触摸反馈只支持iPhone 7/7P</a>，因此在设计触摸反馈时一定要考虑使用场景，不能让有触摸反馈的用户觉得干扰，也不能影响没有触摸反馈用户的体验。 <del>文档里啰啰嗦嗦了这么多苹果爸爸你倒是什么时候给电话接通加个震动提醒啊，这很符合Notification.Success的场景好吗</del></p><h2 id="Taptic-API"><a href="#Taptic-API" class="headerlink" title="Taptic API"></a>Taptic API</h2><p>和iOS Human Interface Guidelines对应，Tapic API用三个子类 <code>UIImpactFeedbackGenerator</code> 、<code>UISelectionFeedbackGenerator</code> 和 <code>UINotificationFeedbackGenerator</code> 来代表三种不同类型的震动。<br>无论是哪种震动，调用的套路基本相同：</p><ol><li>实例化FeedbackGenerator</li><li>调用<code>prepare</code>方法。（非必须）手动调用prepare的好处是可以预先初始化FeedbackGenerator，这样在需要触发震动的时候可以立即响应。当然在实时性不是很强的操作上不调用prepare也没什么关系。</li><li>调用震动方法。不同类型的实例调用的方式不同，比如UIImpactFeedbackGenerator调用的是impactOccurred，而UISelectionFeedbackGenerator调用selectionChanged。</li><li>释放FeedbackGenerator。（非必须）即把FeedbackGenerator实例设为nil。</li></ol><p>我写了个包括各种类型触摸反馈的demo，需要体验的可以戳<a href="https://github.com/zengyun-programmer/TapticEngineSample" target="_blank" rel="noopener">这里</a>。  （PS：亲测demo中的方法都不支持6s， 6s用户表示忧伤，明明我6s用户有Taptic硬件啊/(ㄒoㄒ)/~~）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;感谢组织过年借我只iPhone 7P，赶紧呈上一篇Taptic Engine报答组织&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://codingtime.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>weak变量性能低的原因</title>
    <link href="http://codingtime.me/2016/07/02/weak%E5%8F%98%E9%87%8F%E6%80%A7%E8%83%BD%E4%BD%8E%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>http://codingtime.me/2016/07/02/weak变量性能低的原因/</id>
    <published>2016-07-01T16:06:00.000Z</published>
    <updated>2018-07-15T19:12:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>经常看到说weak变量性能低要少用，但就是没看到文章说明一下原因，于是我弱弱总结一下：</p><ol><li>weak变量使用时会生成autorelease临时变量，增加性能消耗</li><li>所有weak变量都会被加入到weak散列表中，每次有内存释放时都会遍历这个散列表，置空所有的weak变量。如果weak变量太多，遍历散列表将变得非常耗时</li></ol><p>参考资料：<br>《Objective-C 高级编程》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经常看到说weak变量性能低要少用，但就是没看到文章说明一下原因，于是我弱弱总结一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;weak变量使用时会生成autorelease临时变量，增加性能消耗&lt;/li&gt;
&lt;li&gt;所有weak变量都会被加入到weak散列表中，每次有内存释放时都会遍历这
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://codingtime.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://codingtime.me/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>weak-strong dance的另外一种解释</title>
    <link href="http://codingtime.me/2016/07/01/weak-strong%20dance%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E8%A7%A3%E9%87%8A/"/>
    <id>http://codingtime.me/2016/07/01/weak-strong dance的另外一种解释/</id>
    <published>2016-07-01T15:32:00.000Z</published>
    <updated>2018-07-15T19:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下是一个标准的weak-strong dance<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MyViewController *myController = [[MyViewController alloc] init];</span><br><span class="line">// ...</span><br><span class="line">MyViewController * __weak weakMyController = myController;</span><br><span class="line">myController.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    MyViewController *strongMyController = weakMyController;</span><br><span class="line">        if (strongMyController) &#123;</span><br><span class="line">            // ...</span><br><span class="line">            [strongMyController dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Probably nothing...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中所有权修饰符变化过程为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化时为strong-&gt;调用block前转换为weak-&gt;在block中又转换为strong</span><br></pre></td></tr></table></figure></p><p>Google搜出来的大部分博客将这两次修饰符转换的原因解释为：</p><ol><li>strong-&gt;weak：在自己里强引用自己会造成循环引用，因此需要声明一个weak变量供block内使用</li><li>weak-&gt;strong：因为变量对内存对象是弱引用，因此在block执行的内存对象有可能被释放，因此需要声明一个strong的临时变量，保证在block过程中weak所指向的内存不会被释放</li></ol><p>对于第二点我有些异议。<strong>在weak变量调用的过程中，ARC会自动生成一个autorelease的临时变量指向weak所在内存，防止在使用weak变量的过程中其指向的内存区域被释放</strong>，因此在block中并不需要担心weak指向的内存被释放，以上第二点的说法并不能成立。<br>以上观点我们可以在使用weak变量时打印AutoreleasePool的状态来证明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以下打出AutoreleasePool</span><br></pre></td></tr></table></figure></p><p>将OC文件改写成C++，<code>clang -rewrite-objc</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以下打出C++代码</span><br></pre></td></tr></table></figure></p><p>那这时还需不需要使用strong临时变量呢？其实还是需要的。正因为weak在使用的过程中会不断生成autorelease变量，这会产生一定的性能开销，如果这时再声明一个strong变量，并在之后都使用这个strong变量，就避免了调用weak变量会附带生成autorelease变量问题。我想这个才是weak-strong中第二步的真正作用。</p><p>参考资料:<br>《Objective-C高级编程》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是一个标准的weak-strong dance&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://codingtime.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://codingtime.me/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>macOS 配置手册</title>
    <link href="http://codingtime.me/2016/06/28/mac%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>http://codingtime.me/2016/06/28/mac工具推荐/</id>
    <published>2016-06-28T09:53:00.000Z</published>
    <updated>2018-07-15T19:09:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p><a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="noopener">苹果官方文档</a>对Mac的快捷键总结的非常全面。如果一定要给文档勾个重点的话，强烈建议记下常用的“文稿快捷键”，这些快捷键几乎可以在所有的文本框中使用，能极大提高编码效率。</p><h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><h3 id="触摸板"><a href="#触摸板" class="headerlink" title="触摸板"></a>触摸板</h3><ol><li><p>开启轻点<br>需要按下才能单击的默认设置太不人性化了，开启“轻点来点按”，只要轻轻拍一下触摸板就能代替鼠标点击。<br>开启方法：系统偏好设置-&gt;触摸板，将下图的选项勾上</p><p> <img src="../images/23-36-50.jpg" alt=""></p></li><li><p>开启三指拖拽<br>默认的触摸板拖拽设置吃力的不行，一边按住触摸板一边移动手指的操作简直反人类。好在macOS可以用三指拖拽来代替按压拖拽，开启之后拖拽体验不输鼠标。<br>开启方式：系统偏好设置-&gt;辅助功能，然后在左侧列表里选择“鼠标与触摸板”，然后再点击触摸板选项，勾上启用拖移，并在下拉菜单中选择三指拖移。<br>设置好之后，拖移只需要三指滑动就好，不再需要按压啦。<br><img src="../images/23-50-46.jpg" alt=""></p></li></ol><h2 id="生产力工具"><a href="#生产力工具" class="headerlink" title="生产力工具"></a>生产力工具</h2><h3 id="SpotLight"><a href="#SpotLight" class="headerlink" title="SpotLight"></a>SpotLight</h3><p>Spotlight可以说是macOS最大优点，全局文件搜索不能再方便，妈妈再也不用担心我找不到文件了。</p><h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><p>App启动工具，看上去跟SpotLight很像但绝对不仅仅是Spotlight，购买了power package之后就像是打开了新世界的大门，配合不同的workflow让常用操作更加便捷。<br><a href="https://www.zhihu.com/question/20656680" target="_blank" rel="noopener">Alfred workflow玩法戳这里</a></p><h3 id="LaunchBar"><a href="#LaunchBar" class="headerlink" title="LaunchBar"></a>LaunchBar</h3><p>一样是App启动工具，跟Alfred发展方向不太一样，两者各有千秋。虽然我比较喜欢Alfred，但也看到过同事LaunchBar用的行云流水。建议大家两个都体验下，看自己喜好选其一。</p><h3 id="OmniFocus"><a href="#OmniFocus" class="headerlink" title="OmniFocus"></a>OmniFocus</h3><p>任务管理软件。在试用过市面上几乎所有主流任务管理软件之后投靠了OmniFocus的怀抱。除了Inbox、Context、Project等GTD基本功能以外，OmniFocus还有预测、Review、无限分级、聚焦等无比好用的独有功能，作为一只GTD重度用户，在使用的过程中的的确确能体会到OmniFocus对GTD独到的理解。<br>附<a href="http://www.mifengtd.cn/articles/omnifocus-1.html" target="_blank" rel="noopener">OmniFocus设置教程</a>。<br>如果你只是轻度任务管理用户，觉得要学习半天才能上手的OmniFocus过于复杂，<a href="https://www.wunderlist.com/zh/" target="_blank" rel="noopener">奇妙清单</a>或者<a href="https://culturedcode.com/things/" target="_blank" rel="noopener">Things</a>也是不错的选择。</p><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a><a href="https://www.iterm2.com" target="_blank" rel="noopener">iTerm2</a></h3><p>加强版终端，妥妥的吊打系统自带终端。支持标签页、可设置主题、可分屏、各种快捷键操作、支持选中即复制、自动补全、记录粘贴历史……</p><h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a></h3><p>比bash更好用的shell，兼容bash、更强大的补全、支持各种主题、支持显示git分支、支持各种插件，zsh的优点简直要说两天两夜，反正zsh我是走到哪装到哪，哪台电脑上没zsh我用起来就浑身不舒服。</p><h3 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a><a href="http://brew.sh/" target="_blank" rel="noopener">HomeBrew</a></h3><p>包管理工具，有了它安装命令行工具更方便。</p><h3 id="Homebrew-Cask"><a href="#Homebrew-Cask" class="headerlink" title="Homebrew Cask"></a><a href="https://caskroom.github.io" target="_blank" rel="noopener">Homebrew Cask</a></h3><p>基于homebrew的软件安装工具。没有Homebrew Cask之前安装Chrome需要三步：</p><ol><li>去Chrome主页</li><li>下载Chrome安装包</li><li>打开安装包</li></ol><p>有了Homebrew Cask只需要一部：执行<code>brew cask install goole-chrome</code>。不过需要注意的是brew cask安装的软件需要用<code>brew cask uninstall</code>进行删除。<br>另外brew cask也有GUI版，叫<a href="https://www.cakebrew.com/" target="_blank" rel="noopener">Cakebrew</a>。</p><h2 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h2><h3 id="Clean-My-Mac"><a href="#Clean-My-Mac" class="headerlink" title="Clean My Mac"></a><a href="http://macpaw.com/cleanmymac" target="_blank" rel="noopener">Clean My Mac</a></h3><p>磁盘清理工具，在Mac电脑大部分都是SSD，硬盘空间紧张的情况下，这类工具还是挺有用的。另外强力卸载软件的功能在关键时候能帮上大忙。</p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="Command-Line-Tools"><a href="#Command-Line-Tools" class="headerlink" title="Command Line Tools"></a><a href="https://developer.apple.com/library/ios/technotes/tn2339/_index.html" target="_blank" rel="noopener">Command Line Tools</a></h3><p>苹果家出的一个命令行工具集，包括了前后端需要的一个基本命令行工具包，比如git啦、xcodebuild啦、node-gyp啦，许多命令行工具（比如homebrew）都依赖Command Line Tools。<br>在命令行中输入<code>xcode-select --install</code>，即可开始安装。</p><h3 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h3><p><img src="../images/00-54-05.jpg" alt=""></p><p>开发文档查询工具。虽然看上去这就是个文档集合小工具，可以帮你离线各种文档并提供搜索功能，但是配合Alfred查起API来真心感觉方便，谁用谁知道 :) 免费版启动和查询的时候都需要等待几秒，为了提高开发效率，建议付费。（貌似经常打折所以也不贵 =。=）</p><h3 id="OmniPlan"><a href="#OmniPlan" class="headerlink" title="OmniPlan"></a><a href="https://www.omnigroup.com/omniplan" target="_blank" rel="noopener">OmniPlan</a></h3><p>项目计划工具，类似于Windows下的Project。讲真Omni出品必属精品，平常做项目计划所需要的所有功能都能在OmniPlan下找到，除了贵没啥缺点，反正我是没在Mac下面看到比这更好用的项目计划软件了。</p><h3 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a></h3><p>免费而功能强大的Git图形化工具。各种功能都有也支持git flow，除了偶尔不稳定要重启以外没要求了。</p><h3 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">Charles</a></h3><p>简单好用的http抓包工具，支持抓取https请求，除了抓包也可以拦截修改请求。免费版也能用，就是启动要等几秒，且每隔30分钟要强制关闭一次。</p><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><h3 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a><a href="https://www.sublimetext.com" target="_blank" rel="noopener">Sublime Text</a></h3><p>老牌编辑器，前端同学都用它。实测打开80M的文本文件，Visual Studio Code和Atom都挂了只有Sublime能打开。</p><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a><a href="https://atom.io/" target="_blank" rel="noopener">Atom</a></h3><p>Github家的出品，使用CoffeeScript，对前端最友好，自带git，插件众多。</p><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a></h3><p>和Atom一样是基于<code>Electron</code>，据说性能比Atom好很多，体验也不错，作为VS忠粉看到熟悉的配色表示很激动。</p><h3 id="MacDown"><a href="#MacDown" class="headerlink" title="MacDown"></a><a href="http://macdown.uranusjr.com/" target="_blank" rel="noopener">MacDown</a></h3><p>开源markdown编辑器。作者受Mou影响较大，因此MacDown体验和Mou高度一致，对Mou失望的同学可以无缝迁移，稳定性也不错。</p><h3 id="Mou"><a href="#Mou" class="headerlink" title="Mou"></a><a href="http://25.io/mou/" target="_blank" rel="noopener">Mou</a></h3><p>老牌markdown编辑器。有一点点不稳定且作者新版本一直在跳票 XD</p><h2 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h2><h3 id="ClipMenu"><a href="#ClipMenu" class="headerlink" title="ClipMenu"></a><a href="http://www.clipmenu.com/" target="_blank" rel="noopener">ClipMenu</a></h3><p><img src="../images/00-54-32.jpg" alt=""></p><p>剪贴板小工具，可以记录上20次剪贴板里的内容，在多次复制粘贴的时候非常好用。</p><h3 id="iStat-Menus"><a href="#iStat-Menus" class="headerlink" title="iStat Menus"></a><a href="https://bjango.com/mac/istatmenus/" target="_blank" rel="noopener">iStat Menus</a></h3><p>系统状态显示软件，可以显示网络状态、CPU情况、内存使用情况等。</p><h3 id="Bartender"><a href="#Bartender" class="headerlink" title="Bartender"></a><a href="https://www.macbartender.com" target="_blank" rel="noopener">Bartender</a></h3><p><img src="../images/00-40-33.jpg" alt=""><br>菜单图标管理软件，可以将右上角菜单栏的图标隐藏起来。安装的软件多了特别是有了iStat Menus之后，Bartender的意义就体现出来了。</p><h3 id="1Password"><a href="#1Password" class="headerlink" title="1Password"></a>1Password</h3><p>密码管理工具。跟Last Password等工具不同的是1Password的密码文件是存储在本地的，感觉更安全，另外1Password的各种插件和工具做的都不错，买了1Password5还能免费升级到6，真·良心商家。</p><h3 id="Irvue"><a href="#Irvue" class="headerlink" title="Irvue"></a>Irvue</h3><p>自动换壁纸，壁纸来源是高质量高分辨率照片分享网站 Unsplash，照片质量非常不错。</p><h3 id="Surge"><a href="#Surge" class="headerlink" title="Surge"></a>Surge</h3><p>梯子，支持shadowsocks协议，支持全局自动翻。如果没有购买Surge iOS版的话，<a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help" target="_blank" rel="noopener">Shadowsocks </a>或者<a href="https://github.com/chenowen/GoAgentX-1" target="_blank" rel="noopener">GoAgentX</a>也是不错的选择。</p><p>PS：写的过程中发现个不错的GitBook <a href="https://www.gitbook.com/book/aaaaaashu/mac-dev-setup/details" target="_blank" rel="noopener">Mac 开发配置手册</a><br>鸣谢：感谢小谁大人帮我打开Mac大门~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用快捷键&quot;&gt;&lt;a href=&quot;#常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;常用快捷键&quot;&gt;&lt;/a&gt;常用快捷键&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://support.apple.com/zh-cn/HT201236&quot; target=
      
    
    </summary>
    
    
      <category term="macOS" scheme="http://codingtime.me/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>使用FBSimulatorControl做模拟器适配测试</title>
    <link href="http://codingtime.me/2016/06/15/FBSimulatorControl_2016_06_15/"/>
    <id>http://codingtime.me/2016/06/15/FBSimulatorControl_2016_06_15/</id>
    <published>2016-06-15T15:26:58.000Z</published>
    <updated>2018-07-15T18:58:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一只iOS狗，虽然需要适配的屏幕有限，但每次适配自测的时候都挨个去启动N个模拟器也是很心塞。放狗搜到Facebook爸爸在15年的时候就搞了个<code>FBSimulatorControl</code>库支持同时启动多个模拟器，鉴于网上中文配置<code>FBSimulatorControl</code>的教程比较少。于是将自己的探索过程记录一下。</p><h2 id="安装FBSimulatorControl小工具"><a href="#安装FBSimulatorControl小工具" class="headerlink" title="安装FBSimulatorControl小工具"></a>安装FBSimulatorControl小工具</h2><p>首先要加入Facebook Tap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap facebook/fb</span><br></pre></td></tr></table></figure></p><p>然后正常brew安装就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install fbsimctl --HEAD</span><br></pre></td></tr></table></figure></p><h2 id="启动多个模拟器"><a href="#启动多个模拟器" class="headerlink" title="启动多个模拟器"></a>启动多个模拟器</h2><p>首先先看看自己有哪些模拟器，执行<code>fbsimctl list</code>查看自己模拟器列表。<br>然后从列表里挑选自己喜欢的，执行<code>fbsimctl xxx xxx xxx boot</code>即可启动这些服务器。其中xxx是刚刚列表中的设备编号，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fbsimctl 58B41543-C744-40FC-95E8-D47084A45B1F F36F486A-1B53-4B5B-BF3E-F3F50F5CCA99 D329D8D6-EBB6-4FDF-865E-063F67D45CA1 boot</span><br></pre></td></tr></table></figure><h2 id="安装app"><a href="#安装app" class="headerlink" title="安装app"></a>安装app</h2><p>找到要测试的应用的<code>app</code>文件或<code>ipa</code>文件的路径，输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fbsimctl install SomeApp.app</span><br></pre></td></tr></table></figure><p>app即可被安装</p><h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><p>找到你需要安装的应用的<code>.app</code>文件地址，执行<code>fbsimctl install xxx.app</code>，此处xxx需替换成你的app文件名称，执行完后你的app就已经安装到各个模拟器上了。<br>接着执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fbsimctl launch 此处填入你app的bundleID</span><br></pre></td></tr></table></figure></p><p>所有模拟器上的app就被启动了。接下来你就可以愉快地在各个分辨率里戳戳戳了~</p><h2 id="One-more-thing"><a href="#One-more-thing" class="headerlink" title="One more thing"></a>One more thing</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一只iOS狗，虽然需要适配的屏幕有限，但每次适配自测的时候都挨个去启动N个模拟器也是很心塞。放狗搜到Facebook爸爸在15年的时候就搞了个&lt;code&gt;FBSimulatorControl&lt;/code&gt;库支持同时启动多个模拟器，鉴于网上中文配置&lt;code&gt;FBSimu
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://codingtime.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>view controller 与 view 依赖关系探讨</title>
    <link href="http://codingtime.me/2016/03/22/view%20controller%20%E4%B8%8E%20view%20%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8E%A2%E8%AE%A8/"/>
    <id>http://codingtime.me/2016/03/22/view controller 与 view 依赖关系探讨/</id>
    <published>2016-03-22T09:53:00.000Z</published>
    <updated>2018-07-15T19:04:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，从IB中拖出来的outlet Xcode会默认设置为weak，那么代码new出来并且addSubview到self.view的view，我们在property里要设置为strong还是weak呢。</p><h2 id="Weak-or-Strong"><a href="#Weak-or-Strong" class="headerlink" title="Weak or Strong?"></a>Weak or Strong?</h2><p>假设一个ViewController的self.view中有一个Label，那么他们三者的关系是：</p><p><img src="../../images/post/subview_weak_map.png" alt="ViewController--strong--&gt;self.view--strong--&gt;Label"></p><p><strong>可以看到Label的所有者其实是self.view，正常来说一个对象只有一个所有者，如果再将ViewController中的Label引用声明为strong，那么当label从self.view中移除后，label将不会销毁，造成View的冗余。</strong></p><p>于是我们愉快地把Label声明为<code>weak</code>，但是在初始化label的时候，Xcode又猝不及防地扔给我们一个warning。<br><img src="../../images/post/subview_weak_code.png" alt="warning"></p><p>咦，我们<code>addSubview</code>之后<code>self.label</code>不是已经被<code>self.view</code>强引用了嘛，这又是什么鬼为什么Xcode还跟我们说都是weak惹的祸这个对象马上就要被释放了。编译一下试试，发现ViewController里面果然一片雪白，完全没有刚刚加进去的label的影子，看来Xcode没有骗我们。</p><h2 id="Label消失的原因"><a href="#Label消失的原因" class="headerlink" title="Label消失的原因"></a>Label消失的原因</h2><p>我们来逐步分析一下这几句话背后引用计数的变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.label = [[UILabel alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br></pre></td></tr></table></figure><p>这句话其实应该拆成两句话，首先alloc出了一个<code>UILabel</code>的临时变量，然后再使用<code>setLabel</code>将临时变量复制给self.label。其中引用计数变化如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id temp = [[UILabel alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];//tempLabel引用计数为1</span><br><span class="line">[self setLabel: temp];//由于self.label是weak，因此此处引用计数还是1</span><br></pre></td></tr></table></figure><p>然后接下来的代码中没有再用到temp,temp被释放，此时引用计数为0，temp被设为nil，于是self.label也被设为nil</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[temp release];//引用计数变为0</span><br></pre></td></tr></table></figure><p>最后<code>addSubview</code>时只add了一个nil的view，引用计数并不能增加，所以我们在运行时才没有看到new出来的label。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.view addSubview:self.label];//此处等于[self.view addSubview:nil];</span><br></pre></td></tr></table></figure><h2 id="正确的打开方式"><a href="#正确的打开方式" class="headerlink" title="正确的打开方式"></a>正确的打开方式</h2><p>正确的打开方式是先用一个临时变量把init出来的变量hold住，防止<code>temp</code>在执行的过程中被释放，先亮代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UILabel *tempLabel = [[UILabel alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class="line">self.label = tempLabel;</span><br><span class="line">self.label = @&quot;Hello World&quot;;</span><br><span class="line">[self.view addSubview:self.label];</span><br></pre></td></tr></table></figure><p>这段话的引用计数过程是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UILabel *tempLabel = [[UILabel alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br></pre></td></tr></table></figure><p>这句话可以拆成两句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id temp = [[UILabel alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];//temp引用计数为1</span><br><span class="line">UILabel *tempLabel = temp;//局部变量默认是strong，temp引用计数增至2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.label = tempLabel;//self.label是weak,不改变引用计数</span><br><span class="line">self.label = @&quot;Hello World&quot;;</span><br><span class="line">[self.view addSubview:self.label];//引用计数+1，temp的引用计数为3</span><br><span class="line">//这段代码执行完后，临时变量将被释放</span><br><span class="line">[tempLabel release];//temp引用计数为2</span><br><span class="line">[temp release];//temp引用计数为1</span><br></pre></td></tr></table></figure><p>整段话执行完后，既保证了<code>temp</code>在执行过程中过早释放，又保证了在执行完后<code>temp</code>的引用计数为1，因此是初始化<code>UIView</code>的property较为科学的方法。</p><p>本文参考了以下内容：</p><ul><li><a href="http://stackoverflow.com/questions/17517331/best-practice-for-custom-uiview-subview-strong-vs-weak" target="_blank" rel="noopener">Best practice for custom UIView subview strong vs weak</a></li><li><a href="http://stackoverflow.com/questions/11013587/differences-between-strong-and-weak-in-objective-c/11013715#11013715" target="_blank" rel="noopener">Differences between strong and weak in Objective-C</a></li><li><a href="http://stackoverflow.com/questions/23076260/creating-views-programmatically-strong-vs-weak-subviews-in-controller" target="_blank" rel="noopener">Creating views programmatically Strong Vs Weak subviews in controller</a></li><li><a href="http://stackoverflow.com/questions/9747015/why-is-addsubview-not-retaining-the-view" target="_blank" rel="noopener">Why is addSubview: not retaining the view?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众所周知，从IB中拖出来的outlet Xcode会默认设置为weak，那么代码new出来并且addSubview到self.view的view，我们在property里要设置为strong还是weak呢。&lt;/p&gt;
&lt;h2 id=&quot;Weak-or-Strong&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://codingtime.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>溢出无处不在</title>
    <link href="http://codingtime.me/2016/02/29/%E6%BA%A2%E5%87%BA%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8/"/>
    <id>http://codingtime.me/2016/02/29/溢出无处不在/</id>
    <published>2016-02-29T09:53:00.000Z</published>
    <updated>2018-07-15T19:11:09.000Z</updated>
    
    <content type="html"><![CDATA[<p># </p><p>最近需要做个随机数，一般随机数不都是用时间戳作种子然后生成嘛，于是迅速写下以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//取当前时间</span><br><span class="line">NSTimeInterval currentTime = [[NSDate date] timeIntervalSince1970];</span><br><span class="line">//将时间戳的精度取到毫秒级，减少种子雷同的概率</span><br><span class="line">NSTimeInterval timeStamp = (long)(currentTime * 1000);</span><br><span class="line">//srand要求time</span><br><span class="line">srand((unsigned int)timeStamp);</span><br><span class="line">NSInteger randomNumber = rand();</span><br></pre></td></tr></table></figure><p>代码愉快地上线之后，居然有1/5的概率会生成重复的随机数。重新review代码之后，发现太久没有用<code>unsigned int</code>等基本类型，完全无视了各种类型转换赋值之间精度丢失和溢出的问题。</p><p>我们先来复习一下32位下各种基本类型的取值范围</p><table><thead><tr><th>类型</th><th>最小值</th><th>最大值</th><th>字节</th></tr></thead><tbody><tr><td>short int</td><td>-32768</td><td>32767</td><td>2</td></tr><tr><td>unsigned short int</td><td>0</td><td>65535</td><td>2</td></tr><tr><td>int</td><td>-2147483648</td><td>2147483647</td><td>4</td></tr><tr><td>unsigned int</td><td>0</td><td>4294967295</td><td>4</td></tr><tr><td>long</td><td>-2147483648</td><td>2147483647</td><td>4</td></tr><tr><td>unsigned long</td><td>0</td><td>4294967295</td><td>4</td></tr><tr><td>long long</td><td>-9 223 372 036 854 775 808</td><td>9 223 372 036 854 775 807</td><td>8</td></tr><tr><td>unsigned long long</td><td>0</td><td>18 446 744 073 709 551 615</td><td>8</td></tr><tr><td>float</td><td>1.17549e-038</td><td>3.40282e+038</td><td>4</td></tr><tr><td>double</td><td>2.22507e-308</td><td>1.79769e+308</td><td>8</td></tr></tbody></table><p>然后再看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSTimeInterval timeStamp = (long)(currentTime * 1000);</span><br></pre></td></tr></table></figure><p><code>NSTimeInterval</code>是<code>double</code>类型，这里将8字节的<code>double</code>类型强制转换成了4字节<code>long</code>。<code>[[NSDate date] timeIntervalSince1970]</code>获取到的整数部分有11位，再乘以1000之后有14位，妥妥的超过了<code>long</code>的取值范围，于是这里愉快地发生了溢出。老师说过，一个正数溢出之后就变成了最小的负数，所以在这一步，我们本来正正常常的时间戳的种子刷的一下都变成了负数 -2147483648，因此在32位下，无论当前的时间戳是多少，都会生成同样的随机数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;# &lt;/p&gt;
&lt;p&gt;最近需要做个随机数，一般随机数不都是用时间戳作种子然后生成嘛，于是迅速写下以下代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://codingtime.me/tags/iOS/"/>
    
  </entry>
  
</feed>
